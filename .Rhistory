fn <- sapply( x, function(x){return(x[2])} )
fn <- trimws( fn )
fn2 <- strsplit( fn, " " )
fn2 <- sapply( fn2, function(x){return(x[1])} )
fn2 <- trimws( fn2 )
return( fn2 )
}
d$first.name <- get_first_name(d$Full.Name)
add_gender <- function( d )
{
unique.first.names <- unique( d$first.name )
gen <- gender( unique.first.names )
gen <- dplyr::select( gen, name, gender )
d <- merge( d, gen, by.x="first.name", by.y="name", all.x=TRUE )
d$gender[ is.na(d$gender) ] <- "uncoded"
d$gender <- factor( d$gender, levels=c("male","female","uncoded") )
return(d)
}
add_titles <- function(d) {
title <- rep("", nrow(d))
# Assistant Professors
title[grepl("(?=.*\\b(Asst|Assistant)\\b)(?=.*\\b(Prof|Professor)\\b)",
d$Job.Description, ignore.case = TRUE, perl = TRUE)] <- "Assistant Professor"
# Associate Professors
title[grepl("(?=.*\\b(Assoc|Associate|Asc Profr)\\b)(?=.*\\b(Prof|Professor)\\b)",
d$Job.Description, ignore.case = TRUE, perl = TRUE)] <- "Associate Professor"
# Full Professors
title[grepl("Prof|Professor|& Professor", d$Job.Description, ignore.case = TRUE) &
!grepl("Asst|Assoc|Assistant|Associate|Asc Profr", d$Job.Description, ignore.case = TRUE)] <- "Full Professor"
# Research Positions
title[grepl("^Postdoctoral Research Scholar$", d$Job.Description, ignore.case = TRUE)]   <- "Researcher"
title[grepl("Research Specialist", d$Job.Description, ignore.case = TRUE)]               <- "Researcher"
title[grepl("Research Analyst", d$Job.Description, ignore.case = TRUE)]                  <- "Researcher"
title[grepl("Postdoctoral Scholar", d$Job.Description, ignore.case = TRUE)]              <- "Researcher"
title[grepl("Postdoctoral Fellow", d$Job.Description, ignore.case = TRUE)]               <- "Researcher"
title[grepl("Research Scientist", d$Job.Description, ignore.case = TRUE)]                <- "Researcher"
title[grepl("Research Professional", d$Job.Description, ignore.case = TRUE)]             <- "Researcher"
title[grepl("Research Professor", d$Job.Description, ignore.case = TRUE)]                <- "Researcher"
# Teaching Faculty
title[grepl("^Instructor$", d$Job.Description, ignore.case = TRUE)]           <- "Teaching Faculty"
title[grepl("Clinical .+ Professor", d$Job.Description, ignore.case = TRUE)]  <- "Teaching Faculty"
title[grepl("Lecturer$", d$Job.Description, ignore.case = TRUE)]              <- "Teaching Faculty"
title[grepl("^Lecturer Sr$", d$Job.Description, ignore.case = TRUE)]          <- "Teaching Faculty"
title[grepl("^Principal Lecturer$", d$Job.Description, ignore.case = TRUE)]   <- "Teaching Faculty"
title[grepl("Professor of Practice", d$Job.Description, ignore.case = TRUE)]  <- "Teaching Faculty"
title[grepl("Adjunct Faculty", d$Job.Description, ignore.case = TRUE)]        <- "Teaching Faculty"
title[grepl("Teaching Associate", d$Job.Description, ignore.case = TRUE)]     <- "Teaching Faculty"
title[grepl("Senior Lecturer", d$Job.Description, ignore.case = TRUE)]        <- "Teaching Faculty"
# Administrative roles
title[grepl("Dean", d$Job.Description, ignore.case = TRUE)]      <- "Administrator"
title[grepl("Director", d$Job.Description, ignore.case = TRUE)]  <- "Administrator"
title[grepl("Chair", d$Job.Description, ignore.case = TRUE)]     <- "Administrator"
d$title <- factor(title,
levels = c("Full Professor", "Associate Professor",
"Assistant Professor", "Teaching Faculty",
"Researcher", "Administrator"))
return(d)
}
d <- add_titles(d)
unstring_salary <- function(x)
{
x <- gsub( "[$,]", "", x )
x <- as.numeric( x )
return(x)
}
d$salary <- unstring_salary(d$Salary)
make_salary_fte <- function(d)
{
if( max(d$FTE) == 100 )
{  salary <- d$salary / (d$FTE/100) }
if( max(d$FTE) == 1 )
{ salary <- d$salary / d$FTE }
d$salary <- salary
return(d)
}
get_fte <- function( d )
{
d$salary <- unstring_salary( d$Salary )
d <- make_salary_fte(d)
return(d)
}
d <- get_fte(d)
dollarize <- function(x)
{ paste0("$", format( round( x, 0 ), big.mark="," ) ) }
academic.units <-
c("CISA-Intrdisp Hum & Comm", "CISA-Science & Mathmatics",
"College of Health Solutions MS", "College of Health Solutions NT",
"College of Health Solutions SH", "College Of Law", "English", "Hugh Downs School Of Comm",
"Humanities Arts & Cultural", "Journalism & Mass Comm", "Ldrshp and Integrative Studies",
"Math & Natural Sciences Div", "MDT Music", "Physics Department",
"Psychology", "Sch Biological & Hlth Sys Engr", "Sch Compt Infor & Dec Sys Engr",
"Sch Elect Comptr & Energy Engr", "Sch Engr Matter Trnsprt Energy",
"Sch Future of Innov in Society", "Sch Sustain Engr & Built Envrn",
"School Of Art", "School of Criminology & Crim J", "School Of Earth & Space Explor",
"School of Geog Sci & Urban Pln", "School of Math & Stat Sciences",
"School of Molecular Sciences", "School of Politics & Global St",
"School Of Public Affairs", "School of Social Transform", "School Of Social Work",
"SHPRS History Faculty", "Social & Behavioral Sciences", "Sols Administration & Faculty",
"SOS Faculty & Researchers", "The Design School", "The Sanford School",
"WPC Accountancy", "WPC Economics", "WPC Information Systems",
"WPC Management", "WPC Supply Chain Management")
get_study_sample <- function(d) {
d <- d %>%
filter(title != "" & !is.na(title)) %>%
filter(Department.Description %in% academic.units) %>%
arrange(Department.Description, title)
return(d)
}
d <- get_study_sample(d)
nrow( d )
create_salary_table <- function(d) {
t.salary <- d %>%
filter(!is.na(title) & title != "") %>%
group_by(title, gender) %>%
summarize(
q25 = quantile(salary, 0.25, na.rm = TRUE),
q50 = quantile(salary, 0.50, na.rm = TRUE),
q75 = quantile(salary, 0.75, na.rm = TRUE),
n = n()
) %>%
ungroup() %>%
mutate(p = round(n / sum(n), 2))
return(t.salary)
}
add_position <- function( t, position, y, xmax, scale.f=8 )
{
t.original <- t
t <- filter( t.original, title==position )
dot.size <- 2 + scale.f*sum(t$p)
offset.n <- 1 + sum(t$p)*2
male.median <- NA
n.male <- NA
t <- filter( t.original, title==position & gender == "male" )
if( nrow(t) > 0 )
{
male.median <- t$q50
n.male <- t$n
}
female.median <- NA
n.female <- NA
t <- filter( t.original, title==position & gender == "female" )
if( nrow(t) > 0 )
{
female.median <- t$q50
n.female <- t$n
}
# dumbell plots
segments( x0=female.median, x1=male.median, y0=y,
col=gray(0.3,0.5), lwd=7 )
points( male.median, y,
col=adjustcolor( "darkblue", alpha.f = 0.5),
pch=19, cex=dot.size  )
points( female.median, y,
col=adjustcolor( "firebrick", alpha.f = 0.5),
pch=19, cex=dot.size  )
pos.f <- 2
pos.m <- 4
if( ! ( is.na(female.median) | is.na(male.median) ) )
{
pos.f <- ifelse( female.median > male.median, 4, 2 )
pos.m <- ifelse( female.median > male.median, 2, 4 )
}
# add salaries to right and left
text( female.median, y, paste0("$",round(female.median/1000,0),"k"),
col=adjustcolor( "firebrick", alpha.f = 0.7),
cex=1.2, pos=pos.f, offset=offset.n )
text( male.median, y, paste0("$",round(male.median/1000,0),"k"),
col=adjustcolor( "darkblue", alpha.f = 0.7),
cex=1.2, pos=pos.m, offset=offset.n )
# add faculty counts
n.female <- ifelse( is.na(n.female), 0, n.female )
n.female <- ifelse( nchar(n.female)==1,
paste0( " ", n.female), n.female )
n.male <- ifelse( is.na(n.male), 0, n.male )
n.male <- ifelse( nchar(n.male)==1,
paste0( " ", n.male), n.male )
text( xmax-0.1*xmax, y+0.14, paste0( "f   = ", n.female),
col="gray50", cex=1.1, pos=4  )
text( xmax-0.1*xmax, y-0.14, paste0( "m = ", n.male),
col="gray50", cex=1.1, pos=4  )
axis( side=2, at=y, labels=position,
las=2, tick=F, cex.axis=1.5, col.axis="gray50" )
}
build_graph <- function( t.salary, unit )
{
unique.titles <- unique( t.salary$title )
ymax <- length(unique.titles)
xmax <- round( max(t.salary$q50), -3 ) + 50000
color.key.pos <- 40000 + ( xmax - 40000 ) / 2
color.key.inc <- ( xmax - 40000 ) / 10
t.mf <- filter( t.salary, gender %in% c("male","female") )
N <- sum( t.mf$n )
par( mar=c(6,15,4.1,0) )
plot.new()
plot.window( xlim=c(40000-10000,xmax), ylim=c(0,ymax+1) )
abline( v=seq(40000,xmax-40000,20000), lwd=1.5, lty=2, col=gray(0.5,0.5) )
axis( side=1,
at=seq(40000,xmax-40000,20000),
labels=paste0("$",seq(40,(xmax-40000)/1000,20),"k"),
cex.axis=1.1, col.axis="gray40", tick=FALSE )
y <- ymax
if( "Full Professor" %in% unique.titles )
{
add_position( t.salary, position="Full Professor", y, xmax )
y <- y-1
}
if( "Associate Professor" %in% unique.titles )
{
add_position( t.salary, position="Associate Professor", y, xmax )
y <- y-1
}
if( "Assistant Professor" %in% unique.titles )
{
add_position( t.salary, position="Assistant Professor", y, xmax )
y <- y-1
}
if( "Teaching Faculty" %in% unique.titles )
{
add_position( t.salary, position="Teaching Faculty", y, xmax )
y <- y-1
}
if( "Researcher" %in% unique.titles )
{
add_position( t.salary, position="Researcher", y, xmax )
y <- y-1
}
text( color.key.pos + 3*color.key.inc, 0, "MALE",
col=adjustcolor( "darkblue", alpha.f = 0.7), cex=1.2 )
text( color.key.pos + 1.8*color.key.inc, 0, "FEMALE",
col="firebrick",  cex=1.2 )
text( xmax - 0.1*xmax, 0, paste0("N = ",N), col="gray40",  cex=1.2, pos=4 )
title( main="Median Salary by Rank and Gender", cex.main=1.5, col.main="gray30" )
title( xlab=unit, col.lab="gray50", cex.lab=1.5, line=5 )
title( xlab="dot size represents proportion of faculty at that rank",
col.lab="gray50", cex.lab=0.9 )
return(NULL)
}
d %>%
filter(Department.Description == "Psychology") %>%
create_salary_table() %>%
build_graph(unit = "Psychology")
top_five_salaries <- function(d) {
top5 <- d %>%
arrange(desc(salary)) %>%
select(Full.Name, gender, title, salary) %>%
head(5)
top5$salary <- dollarize(top5$salary)
return(top5)
}
top_salaries <- top_five_salaries(d)
for (i in academic.units) {
d2 <- filter(d, Department.Description == i)
if (nrow(d2) == 0) { next }
t.salary <- create_salary_table(d2)
top_salaries <- top_five_salaries(d2)
build_graph(t.salary, unit = i)
cat(paste0("<h2>", i, "</h2>"))
cat("<h3>Salary Summary by Rank & Gender</h3>")
cat(t.salary %>% knitr::kable(format = "html"))
cat("<h3>Top Five Salaries</h3>")
cat(top_salaries %>% knitr::kable(format = "html"))
# Add spacing between sections
cat("<br><hr><br>")
}
knitr::opts_chunk$set(echo = TRUE)
source("utils.R")
for (i in academic.units) {
d2 <- filter(d, Department.Description == i)  # Isolate data for department
if (nrow(d2) == 0) { next }  # Skip departments that do not exist
# Generate tables and graph
t.salary <- create_salary_table(d2)
top_salaries <- top_five_salaries(d2)
build_graph(t.salary, unit = i)
# Display department name
cat(paste0("<h2>", i, "</h2>"))
# Print tables using knitr::kable()
cat("<h3>Salary Summary by Rank & Gender</h3>")
cat(t.salary %>% knitr::kable(format = "html"))
cat("<h3>Top Five Salaries</h3>")
cat(top_salaries %>% knitr::kable(format = "html"))
# Add spacing
cat("<br><hr><br>")
}
d$first.name <- get_first_name(d$Full.Name)
add_gender <- function( d )
{
unique.first.names <- unique( d$first.name )
gen <- gender( unique.first.names )
gen <- dplyr::select( gen, name, gender )
d <- merge( d, gen, by.x="first.name", by.y="name", all.x=TRUE )
d$gender[ is.na(d$gender) ] <- "uncoded"
d$gender <- factor( d$gender, levels=c("male","female","uncoded") )
return(d)
}
d <- add_gender(d)
knitr::opts_chunk$set(echo = TRUE)
source("utils.R")
library(tidymodels) # Load the tidymodels package
install.packages("tidymodels")
library(tidymodels) # Load the tidymodels package
library(tidyverse) # Load the tidymodels package
library(ggplot2)    # For visualization
library(dplyr)      # For data manipulation
set.seed(123)       # For reproducibility
data(mtcars) # Load dataset
glimpse(mtcars) # View structure of the dataset
summary(mtcars) # Get basic summary statistics
mtcars_split <- initial_split(mtcars, prop = 0.8, strata = mpg)
library(caret)      # For model training
install.packages("caret")
library(caret)      # For model training
library(ggplot2)    # For visualization
library(dplyr)      # For data manipulation
set.seed(123)       # For reproducibility
data(mtcars) # Load dataset
glimpse(mtcars) # View structure of the dataset
summary(mtcars) # Get basic summary statistics
train_index <- createDataPartition(mtcars$mpg, p = 0.8, list = FALSE)
mtcars_train <- mtcars[train_index, ]
mtcars_test  <- mtcars[-train_index, ]
create_regression_model <- function(method = "lm", data) {
train(mpg ~ ., data = data, method = method, trControl = trainControl(method = "cv", number = 5))
}
lin_reg_fit <- create_regression_model("lm", mtcars_train)
predict_and_evaluate <- function(model, test_data) {
preds <- predict(model, test_data)
results <- data.frame(Actual = test_data$mpg, Predicted = preds)
rmse <- sqrt(mean((results$Actual - results$Predicted)^2))
r_squared <- cor(results$Actual, results$Predicted)^2
return(list(RMSE = rmse, R_Squared = r_squared, Predictions = results))
}
metrics <- predict_and_evaluate(lin_reg_fit, mtcars_test)
print(metrics)
ggplot(metrics$Predictions, aes(x = Actual, y = Predicted)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(title = "Actual vs. Predicted MPG", x = "Actual MPG", y = "Predicted MPG") +
theme_minimal()
rf_reg_fit <- create_regression_model("rf", mtcars_train)
predict_and_evaluate(rf_reg_fit, mtcars_test)
library(caret)      # For model training
library(ggplot2)    # For visualization
library(dplyr)      # For data manipulation
set.seed(123)       # For reproducibility
data(mtcars) # Load dataset
glimpse(mtcars) # View structure of the dataset
summary(mtcars) # Get basic summary statistics
train_index <- createDataPartition(mtcars$mpg, p = 0.8, list = FALSE)
mtcars_train <- mtcars[train_index, ]
mtcars_test  <- mtcars[-train_index, ]
create_regression_model <- function(method = "lm", data) {
train(mpg ~ ., data = data, method = method, trControl = trainControl(method = "cv", number = 5))
}
lin_reg_fit <- create_regression_model("lm", mtcars_train)
predict_and_evaluate <- function(model, test_data, target) {
preds <- predict(model, test_data)
results <- data.frame(Actual = test_data[[target]], Predicted = preds)
rmse <- sqrt(mean((results$Actual - results$Predicted)^2))
r_squared <- cor(results$Actual, results$Predicted)^2
return(list(RMSE = rmse, R_Squared = r_squared, Predictions = results))
}
metrics <- predict_and_evaluate(lin_reg_fit, mtcars_test, "mpg")
print(metrics)
ggplot(metrics$Predictions, aes(x = Actual, y = Predicted)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(title = "Actual vs. Predicted MPG", x = "Actual MPG", y = "Predicted MPG") +
theme_minimal()
rf_reg_fit <- create_regression_model("rf", mtcars_train)
predict_and_evaluate(rf_reg_fit, mtcars_test, "mpg")
data(diamonds) # Load dataset
glimpse(diamonds) # View structure of the dataset
summary(diamonds$price) # Summary statistics for the target variable
diamonds <- diamonds %>% select(price, carat, cut, color, clarity, depth, table) %>%
filter(price < quantile(price, 0.99)) # Remove top 1% outliers
diamonds$cut <- as.factor(diamonds$cut)
diamonds$color <- as.factor(diamonds$color)
diamonds$clarity <- as.factor(diamonds$clarity)
train_index <- createDataPartition(diamonds$price, p = 0.8, list = FALSE)
diamonds_train <- diamonds[train_index, ]
diamonds_test  <- diamonds[-train_index, ]
diamond_reg_fit <- train(price ~ ., data = diamonds_train, method = "lm", trControl = trainControl(method = "cv", number = 5))
diamond_metrics <- predict_and_evaluate(diamond_reg_fit, diamonds_test, "price")
print(diamond_metrics)
ggplot(diamond_metrics$Predictions, aes(x = Actual, y = Predicted)) +
geom_point(alpha = 0.5) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(title = "Actual vs. Predicted Price", x = "Actual Price", y = "Predicted Price") +
theme_minimal()
library(caret)      # For model training
library(ggplot2)    # For visualization
library(dplyr)      # For data manipulation
set.seed(123)       # For reproducibility
data(mtcars) # Load dataset
glimpse(mtcars) # View structure of the dataset
summary(mtcars) # Get basic summary statistics
train_index <- createDataPartition(mtcars$mpg, p = 0.8, list = FALSE)
mtcars_train <- mtcars[train_index, ]
mtcars_test  <- mtcars[-train_index, ]
create_regression_model <- function(method = "lm", data) {
train(mpg ~ ., data = data, method = method, trControl = trainControl(method = "cv", number = 5))
}
lin_reg_fit <- create_regression_model("lm", mtcars_train)
predict_and_evaluate <- function(model, test_data, target) {
preds <- predict(model, test_data)
results <- data.frame(Actual = test_data[[target]], Predicted = preds)
rmse <- sqrt(mean((results$Actual - results$Predicted)^2))
r_squared <- cor(results$Actual, results$Predicted)^2
return(list(RMSE = rmse, R_Squared = r_squared, Predictions = results))
}
metrics <- predict_and_evaluate(lin_reg_fit, mtcars_test, "mpg")
print(metrics)
ggplot(metrics$Predictions, aes(x = Actual, y = Predicted)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(title = "Actual vs. Predicted MPG", x = "Actual MPG", y = "Predicted MPG") +
theme_minimal()
rf_reg_fit <- create_regression_model("rf", mtcars_train)
predict_and_evaluate(rf_reg_fit, mtcars_test, "mpg")
data(diamonds) # Load dataset
glimpse(diamonds) # View structure of the dataset
summary(diamonds$price) # Summary statistics for the target variable
diamonds <- diamonds %>% select(price, carat, cut, color, clarity, depth, table) %>%
filter(price < quantile(price, 0.99)) # Remove top 1% outliers
diamonds$cut <- as.factor(diamonds$cut)
diamonds$color <- as.factor(diamonds$color)
diamonds$clarity <- as.factor(diamonds$clarity)
train_index <- createDataPartition(diamonds$price, p = 0.8, list = FALSE)
diamonds_train <- diamonds[train_index, ]
diamonds_test  <- diamonds[-train_index, ]
diamond_reg_fit <- train(price ~ ., data = diamonds_train, method = "lm", trControl = trainControl(method = "cv", number = 5))
diamond_metrics <- predict_and_evaluate(diamond_reg_fit, diamonds_test, "price")
print(diamond_metrics)
ggplot(diamond_metrics$Predictions, aes(x = Actual, y = Predicted)) +
geom_point(alpha = 0.5) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(title = "Actual vs. Predicted Price", x = "Actual Price", y = "Predicted Price") +
theme_minimal()
data("airquality") # Load dataset
airquality <- na.omit(airquality) # Remove missing values
dim(airquality) # Check dimensions
summary(airquality) # View summary statistics
set.seed(123)
weather <- data.frame(
Month = rep(5:9, each = 30),
Day = rep(1:30, times = 5),
AvgTemp = runif(150, min = 60, max = 90),
Humidity = runif(150, min = 40, max = 100)
)
glimpse(weather)
merged_data <- inner_join(airquality, weather, by = c("Month", "Day"))
glimpse(merged_data)
merged_data <- merged_data %>% select(Ozone, Solar.R, Wind, Temp, AvgTemp, Humidity)
train_index <- createDataPartition(merged_data$Ozone, p = 0.8, list = FALSE)
merged_train <- merged_data[train_index, ]
merged_test  <- merged_data[-train_index, ]
merged_reg_fit <- train(Ozone ~ ., data = merged_train, method = "lm", trControl = trainControl(method = "cv", number = 5))
merged_metrics <- predict_and_evaluate(merged_reg_fit, merged_test, "Ozone")
print(merged_metrics)
ggplot(merged_metrics$Predictions, aes(x = Actual, y = Predicted)) +
geom_point(alpha = 0.5) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(title = "Actual vs. Predicted Ozone Levels", x = "Actual Ozone", y = "Predicted Ozone") +
theme_minimal()
head(diamond_metrics)
setwd("C:/Users/kenan/OneDrive/Desktop/PAF 514/Lab 7")
setwd("C:/Users/kenan/OneDrive/Desktop/PAF 514/Lab 7")
knitr::opts_chunk$set( echo = F, message=F, warning=F )
build_url <- function( GID )
{
KEY <- "1RoiO9bfpbXowprWdZrgtYXG9_WuK3NFemwlvDGdym7E"
url <- paste0( "https://docs.google.com/spreadsheets/d/", KEY, "/export?gid=", GID, "&format=csv" )
return( url )
}
library(markdown)
## 2020 REPORT
url.2020 <- "https://docs.google.com/spreadsheets/d/1RoiO9bfpbXowprWdZrgtYXG9_WuK3NFemwlvDGdym7E/export?gid=1335284952&format=csv"
rmarkdown::render( input='salary-report.rmd',
output_file = "ASU-2020-Salary-Report.HTML",
params = list( url = url.2020 ) )
build_url <- function( GID )
{
KEY <- "1RoiO9bfpbXowprWdZrgtYXG9_WuK3NFemwlvDGdym7E"
url <- paste0( "https://docs.google.com/spreadsheets/d/", KEY, "/export?gid=", GID, "&format=csv" )
return( url )
}
library(markdown)
## 2020 REPORT
url.2020 <- "https://docs.google.com/spreadsheets/d/1RoiO9bfpbXowprWdZrgtYXG9_WuK3NFemwlvDGdym7E/export?gid=1335284952&format=csv"
rmarkdown::render( input='salary-report.rmd',
output_file = "ASU-2020-Salary-Report.HTML",
params = list( url = url.2020 ) )
## 2019 REPORT
url.2019 <- "https://docs.google.com/spreadsheets/d/1RoiO9bfpbXowprWdZrgtYXG9_WuK3NFemwlvDGdym7E/export?gid=1948400967&format=csv"
rmarkdown::render( input='salary-report.rmd',
output_file = "ASU-2019-Salary-Report.HTML",
params = list( url = url.2019 ) )
## 2018 REPORT
url.2018 <- build_url( GID="169937930" )
rmarkdown::render( input='salary-report.rmd',
output_file = "ASU-2018-Salary-Report.html",
params = list( url = url.2018 ) )
## 2017 REPORT
url.2017 <- build_url( GID="1505080523" )
rmarkdown::render( input='salary-report.rmd',
output_file = "ASU-2017-Salary-Report.html",
params = list( url = url.2017 ) )
## 2016 REPORT
url.2016 <- build_url( GID="873598574" )
rmarkdown::render( input='salary-report.rmd',
output_file = "ASU-2016-Salary-Report.html",
params = list( url = url.2016 ) )
